#include <stdio.h>
#include <string.h>
#include "ResManager/plResManager.h"
#include "Debug/hsExceptions.h"
#include "Debug/plDebug.h"
#include "Util/plString.h"

#include "PRP/Object/plSceneObject.h"
#include "PRP/Object/plDrawInterface.h"
#include "PRP/Geometry/plDrawableSpans.h"

void doHelp(const char* myname) {
    printf("Usage: %s filename.prp objectname\n\n", myname);
}

plString filenameConvert(const char* filename) {
    plString basename = plString(filename).beforeFirst('.');
    return basename + ".obj";
}

void WriteObj(plSceneObject* obj, hsStream* S);

int main(int argc, char** argv) {
    if (argc < 3) {
        doHelp(argv[0]);
        return 0;
    }
    plDebug::Init(plDebug::kDLAll);

    const char* filename = argv[1];
    const char* objName = argv[2];

    plResManager rm;
    plPageInfo* page;
    try {
        page = rm.ReadPage(filename);
    } catch (const hsException& e) {
        plDebug::Error("%s:%lu: %s", e.File(), e.Line(), e.what());
        return 1;
    } catch (const std::exception& e) {
        plDebug::Error("%s", e.what());
        return 1;
    } catch (...) {
        plDebug::Error("Undefined error!");
        return 1;
    }

    hsFileStream* OS = new hsFileStream();
    if (!OS->open(filenameConvert(objName), fmCreate)) {
        fprintf(stderr, "Error opening %s.obj for writing!\n", objName);
        delete OS;
        return 1;
    }
    OS->writeStr("#Generated by Prp2Obj\n");

    std::vector<plKey> SObjs = rm.getKeys(page->getLocation(), kSceneObject);
    for (size_t i = 0; i < SObjs.size(); i++) {
        if (SObjs[i]->getName() == objName)
            WriteObj(plSceneObject::Convert(rm.getObject(SObjs[i])), OS);
    }
    
    delete OS;
    return 0;
}

void WriteObj(plSceneObject* obj, hsStream* S) {
    if (!obj->getDrawInterface().Exists() || !obj->getDrawInterface().isLoaded()) {
        plDebug::Warning("Cannot get draw interface for %s", obj->getKey()->getName().cstr());
        return;
    }
    plDrawInterface* draw = plDrawInterface::Convert(obj->getDrawInterface()->getObj());
    
    S->writeStr(plString::Format("o %s\n", obj->getKey()->getName().cstr()));

    for (size_t i=0; i<draw->getNumDrawables(); i++) {
        plDrawableSpans* span = plDrawableSpans::Convert(draw->getDrawable(i)->getObj());
        plIcicle ice = span->getIcicle(draw->getDrawableKey(i));

        hsTArray<plGBufferVertex> verts = span->getVerts(ice.getGroupIdx(), ice.getVBufferIdx());
        for (size_t j = ice.getVStartIdx(); j < (ice.getVStartIdx() + ice.getVLength()); j++) {
            S->writeStr(plString::Format("v %f %f %f\n",
                        verts[j].fPos.X, verts[j].fPos.Y, verts[j].fPos.Z));
        }

        for (size_t j = ice.getVStartIdx(); j < (ice.getVStartIdx() + ice.getVLength()); j++) {
            S->writeStr(plString::Format("vn %f %f %f\n",
                        verts[j].fNormal.X, verts[j].fNormal.Y, verts[j].fNormal.Z));
        }

        if (span->getBuffer(ice.getGroupIdx())->getNumUVs() > 0) {
            for (size_t j = ice.getVStartIdx(); j < (ice.getVStartIdx() + ice.getVLength()); j++) {
                S->writeStr(plString::Format("vt %f %f %f\n",
                            verts[j].fUVWs[0].X, verts[j].fUVWs[0].Y, verts[j].fUVWs[0].Z));
            }
        }

        hsTArray<unsigned short> indices = span->getIndices(ice.getGroupIdx(), ice.getIBufferIdx());
        for (size_t j = ice.getIStartIdx(); j < (ice.getIStartIdx() + ice.getILength()); j += 3) {
            S->writeStr(plString::Format("f %u %u %u\n",
                        indices[j+0] - ice.getVStartIdx() + 1,
                        indices[j+1] - ice.getVStartIdx() + 1,
                        indices[j+2] - ice.getVStartIdx() + 1));
        }
    }
}

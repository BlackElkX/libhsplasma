#include <stdio.h>
#include <string.h>
#include "ResManager/plResManager.h"
#include "Debug/hsExceptions.h"
#include "Debug/plDebug.h"
#include "Util/plString.h"
#include "Util/hsTArray.hpp"

#include "PRP/Object/plSceneObject.h"
#include "PRP/Object/plDrawInterface.h"
#include "PRP/Geometry/plDrawableSpans.h"

void doHelp(const char* myname) {
    printf("Usage: %s filename.prp [options] [objectname ...]\n\n", myname);
    printf("Options:\n");
    printf("    -o file  Write the output to `file`\n");
    printf("    --help   Display this message\n\n");
    printf("If no object is specified, all objects in the file will be dumped.\n\n");
}

plString filenameConvert(const char* filename) {
    plString basename = plString(filename).beforeFirst('.');
    return basename + ".obj";
}

void WriteObj(plSceneObject* obj, hsStream* S);

int main(int argc, char** argv) {
    if (argc < 2) {
        doHelp(argv[0]);
        return 0;
    }
    plDebug::Init(plDebug::kDLAll);

    const char* filename = argv[1];
    plString outfile = filenameConvert(filename);
    hsTArray<plString> objects;
    
    for (int i=2; i<argc; i++) {
        if (argv[i][0] == '-') {
            if (strcmp(argv[i], "-o") == 0) {
                if (i+1 >= argc) {
                    printf("No output filename supplied\n");
                    return 0;
                } else {
                    outfile = argv[++i];
                }
            } else if (strcmp(argv[i], "--help") == 0) {
                doHelp(argv[0]);
                return 0;
            } else {
                printf("Unrecognized option: %s\n", argv[i]);
            }
        } else {
            objects.append(argv[i]);
        }
    }

    plResManager rm;
    plPageInfo* page;
    try {
        page = rm.ReadPage(filename);
    } catch (const hsException& e) {
        plDebug::Error("%s:%lu: %s", e.File(), e.Line(), e.what());
        return 1;
    } catch (const std::exception& e) {
        plDebug::Error("%s", e.what());
        return 1;
    } catch (...) {
        plDebug::Error("Undefined error!");
        return 1;
    }

    hsFileStream* OS = new hsFileStream();
    if (!OS->open(outfile, fmCreate)) {
        fprintf(stderr, "Error opening %s for writing!\n", outfile.cstr());
        delete OS;
        return 1;
    }
    OS->writeStr("#Generated by Prp2Obj\n");

    size_t nObjects = 0;
    try {
        std::vector<plKey> SObjs = rm.getKeys(page->getLocation(), kSceneObject);
        for (size_t i = 0; i < SObjs.size(); i++) {
            if (objects.empty() || objects.find(SObjs[i]->getName()) != (size_t)-1) {
                plSceneObject* obj = plSceneObject::Convert(rm.getObject(SObjs[i]));
                if (obj->getDrawInterface().Exists())
                    WriteObj(obj, OS);
                nObjects++;
            }
        }
    } catch (const hsException& e) {
        plDebug::Error("%s:%lu: %s", e.File(), e.Line(), e.what());
        return 1;
    }
    printf("Successfully wrote %u objects\n", nObjects);
    
    delete OS;
    return 0;
}

static size_t s_BaseIndex = 1;

void WriteObj(plSceneObject* obj, hsStream* S) {
    if (!obj->getDrawInterface().isLoaded()) {
        plDebug::Warning("Cannot get draw interface for %s", obj->getKey()->getName().cstr());
        return;
    }
    plDrawInterface* draw = plDrawInterface::Convert(obj->getDrawInterface()->getObj());
    
    S->writeStr(plString::Format("\no %s\n", obj->getKey()->getName().cstr()));
    for (size_t i=0; i<draw->getNumDrawables(); i++) {
        if (draw->getDrawableKey(i) == -1)
            continue;
        
        plDrawableSpans* span = plDrawableSpans::Convert(draw->getDrawable(i)->getObj());
        plDISpanIndex* di = span->getDIIndex(draw->getDrawableKey(i));
        for (size_t idx=0; idx<di->fIndices.getSize(); idx++) {
            plIcicle ice = span->getIcicle(di->fIndices[idx]);
            S->writeStr("g\n");
            
            hsTArray<plGBufferVertex> verts = span->getVerts(ice.getGroupIdx(), ice.getVBufferIdx());
            for (size_t j = ice.getVStartIdx(); j < (ice.getVStartIdx() + ice.getVLength()); j++) {
                S->writeStr(plString::Format("v %f %f %f\n",
                            verts[j].fPos.X, verts[j].fPos.Y, verts[j].fPos.Z));
            }

            for (size_t j = ice.getVStartIdx(); j < (ice.getVStartIdx() + ice.getVLength()); j++) {
                S->writeStr(plString::Format("vn %f %f %f\n",
                            verts[j].fNormal.X, verts[j].fNormal.Y, verts[j].fNormal.Z));
            }

            if (span->getBuffer(ice.getGroupIdx())->getNumUVs() > 0) {
                for (size_t j = ice.getVStartIdx(); j < (ice.getVStartIdx() + ice.getVLength()); j++) {
                    S->writeStr(plString::Format("vt %f %f %f\n",
                                verts[j].fUVWs[0].X, verts[j].fUVWs[0].Y, verts[j].fUVWs[0].Z));
                }
            }

            hsTArray<unsigned short> indices = span->getIndices(ice.getGroupIdx(), ice.getIBufferIdx());
            for (size_t j = ice.getIStartIdx(); j < (ice.getIStartIdx() + ice.getILength()); j += 3) {
                S->writeStr(plString::Format("f %u %u %u\n",
                            indices[j+0] - ice.getVStartIdx() + s_BaseIndex,
                            indices[j+1] - ice.getVStartIdx() + s_BaseIndex,
                            indices[j+2] - ice.getVStartIdx() + s_BaseIndex));
            }
            s_BaseIndex += ice.getVLength();
        }
    }
}

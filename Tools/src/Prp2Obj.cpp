#include <stdio.h>
#include <string.h>
#include "ResManager/plResManager.h"
#include "Debug/hsExceptions.h"
#include "Debug/plDebug.h"
#include "Util/plString.h"
#include "Util/hsTArray.hpp"

#include "PRP/Object/plSceneObject.h"
#include "PRP/Object/plDrawInterface.h"
#include "PRP/Object/plCoordinateInterface.h"
#include "PRP/Geometry/plDrawableSpans.h"

void doHelp(const char* myname) {
    printf("Usage: %s filename.prp [options] [objectname ...]\n\n", myname);
    printf("Options:\n");
    printf("    -o file  Write the output to `file`\n");
    printf("    --help   Display this message\n\n");
    printf("If no object is specified, all objects in the file will be dumped.\n\n");
}

plString filenameConvert(const char* filename) {
    plString basename = plString(filename).beforeFirst('.');
    return basename + ".obj";
}

void WriteObj(plSceneObject* obj, hsStream* S, bool doXform);

int main(int argc, char** argv) {
    if (argc < 2) {
        doHelp(argv[0]);
        return 0;
    }
    plDebug::Init(plDebug::kDLAll);

    const char* filename = argv[1];
    plString outfile = filenameConvert(filename);
    hsTArray<plString> objects;
    
    for (int i=2; i<argc; i++) {
        if (argv[i][0] == '-') {
            if (strcmp(argv[i], "-o") == 0) {
                if (i+1 >= argc) {
                    printf("No output filename supplied\n");
                    return 0;
                } else {
                    outfile = argv[++i];
                }
            } else if (strcmp(argv[i], "--help") == 0) {
                doHelp(argv[0]);
                return 0;
            } else {
                printf("Unrecognized option: %s\n", argv[i]);
            }
        } else {
            objects.append(argv[i]);
        }
    }

    plResManager rm;
    plPageInfo* page;
    try {
        page = rm.ReadPage(filename);
    } catch (const hsException& e) {
        plDebug::Error("%s:%lu: %s", e.File(), e.Line(), e.what());
        return 1;
    } catch (const std::exception& e) {
        plDebug::Error("%s", e.what());
        return 1;
    } catch (...) {
        plDebug::Error("Undefined error!");
        return 1;
    }

    hsFileStream* OS = new hsFileStream();
    if (!OS->open(outfile, fmCreate)) {
        fprintf(stderr, "Error opening %s for writing!\n", outfile.cstr());
        delete OS;
        return 1;
    }
    OS->writeStr("#Generated by Prp2Obj\n");

    size_t nObjects = 0;
    try {
        std::vector<plKey> SObjs = rm.getKeys(page->getLocation(), kSceneObject);
        for (size_t i = 0; i < SObjs.size(); i++) {
            if (objects.empty() || objects.find(SObjs[i]->getName()) != (size_t)-1) {
                plSceneObject* obj = plSceneObject::Convert(rm.getObject(SObjs[i]));
                if (obj->getDrawInterface().Exists())
                    WriteObj(obj, OS, objects.empty());
                nObjects++;
            }
        }
    } catch (const hsException& e) {
        plDebug::Error("%s:%lu: %s", e.File(), e.Line(), e.what());
        return 1;
    }
    printf("Successfully wrote %u objects\n", nObjects);
    
    delete OS;
    return 0;
}

static size_t s_BaseIndex = 1;
static size_t s_TexBaseIndex = 1;

void WriteObj(plSceneObject* obj, hsStream* S, bool doXform) {
    if (!obj->getDrawInterface().isLoaded()) {
        plDebug::Warning("Cannot get draw interface for %s", obj->getKey()->getName().cstr());
        return;
    }
    plDrawInterface* draw = plDrawInterface::Convert(obj->getDrawInterface()->getObj());
    plCoordinateInterface* coord = NULL;
    if (obj->getCoordInterface().Exists())
        coord = plCoordinateInterface::Convert(obj->getCoordInterface()->getObj());
    
    S->writeStr(plString::Format("\ng %s\n", obj->getKey()->getName().cstr()));
    for (size_t i=0; i<draw->getNumDrawables(); i++) {
        if (draw->getDrawableKey(i) == -1)
            continue;
        
        plDrawableSpans* span = plDrawableSpans::Convert(draw->getDrawable(i)->getObj());
        plDISpanIndex di = span->getDIIndex(draw->getDrawableKey(i));
        for (size_t idx=0; idx<di.fIndices.getSize(); idx++) {
            plIcicle* ice = (plIcicle*)span->getSpan(di.fIndices[idx]);
            hsTArray<plGBufferVertex> verts = span->getVerts(ice);
            hsTArray<unsigned short> indices = span->getIndices(ice);
            
            for (size_t j = 0; j < verts.getSize(); j++) {
                hsVector3 pos;
                if (doXform) {
                    if (coord != NULL)
                        pos = verts[j].fPos * coord->getLocalToWorld() * 10.0f;
                    else
                        pos = verts[j].fPos * ice->getLocalToWorld() * 10.0f;
                } else {
                    pos = verts[j].fPos * 10.0f;
                }
                S->writeStr(plString::Format("v %f %f %f\n", pos.X, pos.Z, -pos.Y));
            }

            if (span->getBuffer(ice->getGroupIdx())->getNumUVs() > 0) {
                for (size_t j = 0; j < verts.getSize(); j++) {
                    S->writeStr(plString::Format("vt %f %f %f\n",
                                verts[j].fUVWs[0].X,
                                verts[j].fUVWs[0].Y,
                                verts[j].fUVWs[0].Z));
                }
            }

            for (size_t j = 0; j < verts.getSize(); j++) {
                S->writeStr(plString::Format("vn %f %f %f\n",
                            verts[j].fNormal.X,
                            verts[j].fNormal.Z,
                            -verts[j].fNormal.Y));
            }

            if (span->getBuffer(ice->getGroupIdx())->getNumUVs() > 0) {
                for (size_t j = 0; j < indices.getSize(); j += 3) {
                    S->writeStr(plString::Format("f %u/%u/%u %u/%u/%u %u/%u/%u\n",
                                indices[j+0] + s_BaseIndex,
                                indices[j+0] + s_TexBaseIndex,
                                indices[j+0] + s_BaseIndex,
                                indices[j+1] + s_BaseIndex,
                                indices[j+1] + s_TexBaseIndex,
                                indices[j+1] + s_BaseIndex,
                                indices[j+2] + s_BaseIndex,
                                indices[j+2] + s_TexBaseIndex,
                                indices[j+2] + s_BaseIndex));
                }
                s_BaseIndex += ice->getVLength();
                s_TexBaseIndex += ice->getVLength();
            } else {
                for (size_t j = 0; j < indices.getSize(); j += 3) {
                    S->writeStr(plString::Format("f %u//%u %u//%u %u//%u\n",
                                indices[j+0] + s_BaseIndex,
                                indices[j+0] + s_BaseIndex,
                                indices[j+1] + s_BaseIndex,
                                indices[j+1] + s_BaseIndex,
                                indices[j+2] + s_BaseIndex,
                                indices[j+2] + s_BaseIndex));
                }
                s_BaseIndex += ice->getVLength();
            }
        }
    }
}
